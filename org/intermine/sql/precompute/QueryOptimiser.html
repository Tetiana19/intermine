<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.11-ea) on Mon Apr 26 18:07:34 BST 2021 -->
<title>QueryOptimiser (intermine unspecified API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2021-04-26">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="QueryOptimiser (intermine unspecified API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">org.intermine.sql.precompute</a></div>
<h2 title="Class QueryOptimiser" class="title">Class QueryOptimiser</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.intermine.sql.precompute.QueryOptimiser</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public final class <span class="typeNameLabel">QueryOptimiser</span>
extends java.lang.Object</pre>
<div class="block">A static class providing the code to optimise a query, given a database (presumably with a table
 describing the available precomputed tables).</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Matthew Wakeling, Andrew Varley</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected static class&nbsp;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="QueryOptimiser.AbstractTableComparator.html" title="class in org.intermine.sql.precompute">QueryOptimiser.AbstractTableComparator</a></span></code></th>
<td class="colLast">
<div class="block">Compares two AbstractTables using their equalsIgnoreAlias() method.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#addNonCoveredFrom(java.util.Set,java.util.Set,java.util.Set)">addNonCoveredFrom</a></span>&#8203;(java.util.Set&lt;T&gt;&nbsp;input,
                 java.util.Set&lt;T&gt;&nbsp;subtract,
                 java.util.Set&lt;T&gt;&nbsp;output)</code></th>
<td class="colLast">
<div class="block">Adds all required FROM items to the FROM list of the new query.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareConstraints(java.util.Set,java.util.Set,java.util.Set)">compareConstraints</a></span>&#8203;(java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;set1,
                  java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;set2,
                  java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;equalsSet)</code></th>
<td class="colLast">
<div class="block">Compares 2 sets of AbstractConstraints</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>protected static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareConstraints(java.util.Set,java.util.Set,java.util.Set,java.util.Map,java.util.Map)">compareConstraints</a></span>&#8203;(java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;set1,
                  java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;set2,
                  java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;equalsSet,
                  java.util.Map&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>,&#8203;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableMap,
                  java.util.Map&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>,&#8203;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;reverseTableMap)</code></th>
<td class="colLast">
<div class="block">Compares 2 sets of AbstractConstraints</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected static boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareSelectLists(java.util.List,java.util.List)">compareSelectLists</a></span>&#8203;(java.util.List&lt;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;list1,
                  java.util.List&lt;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;list2)</code></th>
<td class="colLast">
<div class="block">Compares two Lists of SelectValues, and returns true if all the items in the first List are
 present in the second List, ignoring the SelectValue alias.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>protected static <a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#findTableForAlias(java.lang.String,java.util.Set)">findTableForAlias</a></span>&#8203;(java.lang.String&nbsp;alias,
                 java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;set)</code></th>
<td class="colLast">
<div class="block">Finds a table in a Set with the given alias.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected static java.util.Set&lt;<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#merge(org.intermine.sql.precompute.PrecomputedTable,org.intermine.sql.query.Query,org.intermine.sql.query.Query)">merge</a></span>&#8203;(<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&nbsp;precomputedTable,
     <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
     <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery)</code></th>
<td class="colLast">
<div class="block">Finds all the possible uses of a given precomputed table in the query, and returns them as
 a Set of new Queries.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>protected static java.util.Set&lt;<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeGroupBy(org.intermine.sql.precompute.PrecomputedTable,org.intermine.sql.query.Query,org.intermine.sql.query.Query)">mergeGroupBy</a></span>&#8203;(<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&nbsp;precomputedTable,
            <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
            <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery)</code></th>
<td class="colLast">
<div class="block">Tries to match a PrecomputedTable with a GROUP BY clause to this query.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>protected static java.util.SortedMap&lt;<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>,&#8203;java.util.Set&lt;<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mergeMultiple(java.util.Set,org.intermine.sql.query.Query,org.intermine.sql.query.Query)">mergeMultiple</a></span>&#8203;(java.util.Set&lt;<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&gt;&nbsp;precomputedTables,
             <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
             <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery)</code></th>
<td class="colLast">
<div class="block">Iteratively calls merge on query with all the PrecomputedTables in a Set, returning the
 results in a Map from the PrecomputedTable to the Set that merge returns.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#optimise(java.lang.String,org.intermine.sql.Database)">optimise</a></span>&#8203;(java.lang.String&nbsp;query,
        <a href="../Database.html" title="class in org.intermine.sql">Database</a>&nbsp;database)</code></th>
<td class="colLast">
<div class="block">Runs the optimiser through the query represented in the String, given the database.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#optimise(java.lang.String,org.intermine.sql.Database,org.intermine.sql.precompute.QueryOptimiserContext)">optimise</a></span>&#8203;(java.lang.String&nbsp;query,
        <a href="../Database.html" title="class in org.intermine.sql">Database</a>&nbsp;database,
        <a href="QueryOptimiserContext.html" title="class in org.intermine.sql.precompute">QueryOptimiserContext</a>&nbsp;context)</code></th>
<td class="colLast">
<div class="block">Runs the optimiser through the query represented in the String, given the database.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static <a href="BestQuery.html" title="class in org.intermine.sql.precompute">BestQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#optimise(java.lang.String,org.intermine.sql.query.Query,java.lang.Object,java.sql.Connection,org.intermine.sql.precompute.QueryOptimiserContext)">optimise</a></span>&#8203;(java.lang.String&nbsp;query,
        <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery,
        java.lang.Object&nbsp;precompLookup,
        java.sql.Connection&nbsp;explainConnection,
        <a href="QueryOptimiserContext.html" title="class in org.intermine.sql.precompute">QueryOptimiserContext</a>&nbsp;context)</code></th>
<td class="colLast">
<div class="block">Runs the optimiser through the query represented in the String and Query, given the
 Connection and an object to lookup a PrecomputedTable</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>protected static <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#optimise(org.intermine.sql.query.Query,org.intermine.sql.Database)">optimise</a></span>&#8203;(<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
        <a href="../Database.html" title="class in org.intermine.sql">Database</a>&nbsp;database)</code></th>
<td class="colLast">
<div class="block">Runs the optimiser through the query, given the database.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>protected static <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#optimise(org.intermine.sql.query.Query,org.intermine.sql.Database,org.intermine.sql.precompute.QueryOptimiserContext)">optimise</a></span>&#8203;(<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
        <a href="../Database.html" title="class in org.intermine.sql">Database</a>&nbsp;database,
        <a href="QueryOptimiserContext.html" title="class in org.intermine.sql.precompute">QueryOptimiserContext</a>&nbsp;context)</code></th>
<td class="colLast">
<div class="block">Runs the optimiser through the query, given the database.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static <a href="BestQuery.html" title="class in org.intermine.sql.precompute">BestQuery</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#optimiseWith(java.lang.String,org.intermine.sql.query.Query,org.intermine.sql.Database,java.sql.Connection,org.intermine.sql.precompute.QueryOptimiserContext,java.util.Set,org.intermine.sql.precompute.OptimiserCache)">optimiseWith</a></span>&#8203;(java.lang.String&nbsp;query,
            <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery,
            <a href="../Database.html" title="class in org.intermine.sql">Database</a>&nbsp;database,
            java.sql.Connection&nbsp;connection,
            <a href="QueryOptimiserContext.html" title="class in org.intermine.sql.precompute">QueryOptimiserContext</a>&nbsp;context,
            java.util.Set&lt;<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&gt;&nbsp;precomputedTables,
            <a href="OptimiserCache.html" title="class in org.intermine.sql.precompute">OptimiserCache</a>&nbsp;cache)</code></th>
<td class="colLast">
<div class="block">Runs the optimiser through the query repesented in the String and Query, given the Connection
 and a set of PrecomputedTables.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>protected static <a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reconstructAbstractConstraint(org.intermine.sql.query.AbstractConstraint,org.intermine.sql.query.Table,java.util.Map,java.util.Set,boolean,org.intermine.sql.query.Field,int,org.intermine.sql.query.Field,boolean,boolean)">reconstructAbstractConstraint</a></span>&#8203;(<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&nbsp;oldConstraint,
                             <a href="../query/Table.html" title="class in org.intermine.sql.query">Table</a>&nbsp;precomputedSqlTable,
                             java.util.Map&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>,&#8203;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;valueMap,
                             java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableSet,
                             boolean&nbsp;groupBy,
                             <a href="../query/Field.html" title="class in org.intermine.sql.query">Field</a>&nbsp;firstPrecompOrderBy,
                             int&nbsp;precompOrderBySize,
                             <a href="../query/Field.html" title="class in org.intermine.sql.query">Field</a>&nbsp;orderByField,
                             boolean&nbsp;firstPrecompOrderByHasNoNulls,
                             boolean&nbsp;reverseOrderBy)</code></th>
<td class="colLast">
<div class="block">Reconstructs an AbstractConstraint object, using reconstructAbstractValue.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>protected static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reconstructAbstractConstraints(java.util.Set,org.intermine.sql.query.Table,java.util.Map,java.util.Set,boolean,java.util.Set,java.util.Set,org.intermine.sql.query.Field,int,org.intermine.sql.query.Field,boolean,boolean)">reconstructAbstractConstraints</a></span>&#8203;(java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;oldConstraints,
                              <a href="../query/Table.html" title="class in org.intermine.sql.query">Table</a>&nbsp;precomputedSqlTable,
                              java.util.Map&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>,&#8203;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;valueMap,
                              java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableSet,
                              boolean&nbsp;groupBy,
                              java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;newConstraints,
                              java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;constraintEqualsSet,
                              <a href="../query/Field.html" title="class in org.intermine.sql.query">Field</a>&nbsp;firstPrecompOrderBy,
                              int&nbsp;precompOrderBySize,
                              <a href="../query/Field.html" title="class in org.intermine.sql.query">Field</a>&nbsp;orderByField,
                              boolean&nbsp;firstPrecompOrderByHasNoNulls,
                              boolean&nbsp;reverseOrderBy)</code></th>
<td class="colLast">
<div class="block">Populates the WHERE list of a new Query object, given the old Query's WHERE (or HAVING) list
 to use as a reference.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>protected static <a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reconstructAbstractValue(org.intermine.sql.query.AbstractValue,org.intermine.sql.query.Table,java.util.Map,java.util.Set,boolean)">reconstructAbstractValue</a></span>&#8203;(<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>&nbsp;original,
                        <a href="../query/Table.html" title="class in org.intermine.sql.query">Table</a>&nbsp;precomputedSqlTable,
                        java.util.Map&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>,&#8203;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;valueMap,
                        java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableSet,
                        boolean&nbsp;groupBy)</code></th>
<td class="colLast">
<div class="block">Reconstructs an AbstractValue, to form the part of an SQL Query that has been replaced with
 a PrecomputedTable.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reconstructAbstractValues(java.util.Collection,org.intermine.sql.query.Table,java.util.Map,java.util.Set,boolean,java.util.Collection)">reconstructAbstractValues</a></span>&#8203;(java.util.Collection&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>&gt;&nbsp;oldValues,
                         <a href="../query/Table.html" title="class in org.intermine.sql.query">Table</a>&nbsp;precomputedSqlTable,
                         java.util.Map&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>,&#8203;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;valueMap,
                         java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableSet,
                         boolean&nbsp;groupBy,
                         java.util.Collection&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>&gt;&nbsp;newValues)</code></th>
<td class="colLast">
<div class="block">Reconstructs a Collection of AbstractValue objects, calling reconstructAbstractValue on each
 one before adding it to another Collection.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>protected static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#reconstructSelectValues(java.util.List,org.intermine.sql.query.Table,java.util.Map,java.util.Set,boolean,org.intermine.sql.query.Query)">reconstructSelectValues</a></span>&#8203;(java.util.List&lt;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;oldSelect,
                       <a href="../query/Table.html" title="class in org.intermine.sql.query">Table</a>&nbsp;precomputedSqlTable,
                       java.util.Map&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>,&#8203;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;valueMap,
                       java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableSet,
                       boolean&nbsp;groupBy,
                       <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;newQuery)</code></th>
<td class="colLast">
<div class="block">Populates the SELECT list of a new Query object, given an old Query's SELECT list to use as a
 reference, a valueMap (to pass to reconstructAbstractValue), and a Table to represent the
 PrecomputedTable.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recursiveOptimise(java.util.Set,org.intermine.sql.query.Query,org.intermine.sql.precompute.BestQuery,org.intermine.sql.query.Query)">recursiveOptimise</a></span>&#8203;(java.util.Set&lt;<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&gt;&nbsp;precomputedTables,
                 <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
                 <a href="BestQuery.html" title="class in org.intermine.sql.precompute">BestQuery</a>&nbsp;bestQuery,
                 <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery)</code></th>
<td class="colLast">
<div class="block">Recursively optimises the query, given the set of precomputed tables, and updates the
 BestQuery object with each Query found.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#recursiveOptimiseCheckSubquery(java.util.Set,org.intermine.sql.query.Query,org.intermine.sql.precompute.BestQuery)">recursiveOptimiseCheckSubquery</a></span>&#8203;(java.util.Set&lt;<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&gt;&nbsp;precomputedTables,
                              <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
                              <a href="BestQuery.html" title="class in org.intermine.sql.precompute">BestQuery</a>&nbsp;bestQuery)</code></th>
<td class="colLast">
<div class="block">Recursively optimises the query, given the set of precomputed tables, and updates the
 BestQuery object with each Query found.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>protected static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#remapAliases(java.util.Map,java.util.Set)">remapAliases</a></span>&#8203;(java.util.Map&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>,&#8203;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;map,
            java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tables)</code></th>
<td class="colLast">
<div class="block">Alters all the aliases of the tables being mapped to, to equal the alias of the table mapping
 to them.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>protected static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#remapAliasesToAvoidPrecomputePrefix(org.intermine.sql.query.Query)">remapAliasesToAvoidPrecomputePrefix</a></span>&#8203;(<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query)</code></th>
<td class="colLast">
<div class="block">Remaps the aliases of any table that starts with the ALIAS_PREFIX, to avoid clashes with
 future precomputed tables.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="optimise(java.lang.String,org.intermine.sql.Database)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>optimise</h4>
<pre class="methodSignature">public static&nbsp;java.lang.String&nbsp;optimise&#8203;(java.lang.String&nbsp;query,
                                        <a href="../Database.html" title="class in org.intermine.sql">Database</a>&nbsp;database)
                                 throws java.sql.SQLException</pre>
<div class="block">Runs the optimiser through the query represented in the String, given the database. If
 anything goes wrong, then the original String is returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>query</code> - the query to optimise</dd>
<dd><code>database</code> - the database to use to find precomputed tables</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a String representing the optimised query</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database error occurs</dd>
</dl>
</li>
</ul>
<a id="optimise(java.lang.String,org.intermine.sql.Database,org.intermine.sql.precompute.QueryOptimiserContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>optimise</h4>
<pre class="methodSignature">public static&nbsp;java.lang.String&nbsp;optimise&#8203;(java.lang.String&nbsp;query,
                                        <a href="../Database.html" title="class in org.intermine.sql">Database</a>&nbsp;database,
                                        <a href="QueryOptimiserContext.html" title="class in org.intermine.sql.precompute">QueryOptimiserContext</a>&nbsp;context)
                                 throws java.sql.SQLException</pre>
<div class="block">Runs the optimiser through the query represented in the String, given the database. If
 anything goes wrong, then the original String is returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>query</code> - the query to optimise</dd>
<dd><code>database</code> - the database to use to find precomputed tables</dd>
<dd><code>context</code> - a QueryOptimiserContext, to alter settings</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a String representing the optimised query</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database error occurs</dd>
</dl>
</li>
</ul>
<a id="optimise(org.intermine.sql.query.Query,org.intermine.sql.Database)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>optimise</h4>
<pre class="methodSignature">protected static&nbsp;<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;optimise&#8203;(<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
                                <a href="../Database.html" title="class in org.intermine.sql">Database</a>&nbsp;database)
                         throws java.sql.SQLException</pre>
<div class="block">Runs the optimiser through the query, given the database.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>query</code> - the Query to optimise</dd>
<dd><code>database</code> - the database to use to find precomputed tables</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the optimised Query</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database error occurs</dd>
</dl>
</li>
</ul>
<a id="optimise(org.intermine.sql.query.Query,org.intermine.sql.Database,org.intermine.sql.precompute.QueryOptimiserContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>optimise</h4>
<pre class="methodSignature">protected static&nbsp;<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;optimise&#8203;(<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
                                <a href="../Database.html" title="class in org.intermine.sql">Database</a>&nbsp;database,
                                <a href="QueryOptimiserContext.html" title="class in org.intermine.sql.precompute">QueryOptimiserContext</a>&nbsp;context)
                         throws java.sql.SQLException</pre>
<div class="block">Runs the optimiser through the query, given the database.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>query</code> - the Query to optimise</dd>
<dd><code>database</code> - the database to use to find precomputed tables</dd>
<dd><code>context</code> - a QueryOptimiserContext, to alter settings</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the optimised Query</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database error occurs</dd>
</dl>
</li>
</ul>
<a id="optimise(java.lang.String,org.intermine.sql.query.Query,java.lang.Object,java.sql.Connection,org.intermine.sql.precompute.QueryOptimiserContext)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>optimise</h4>
<pre class="methodSignature">public static&nbsp;<a href="BestQuery.html" title="class in org.intermine.sql.precompute">BestQuery</a>&nbsp;optimise&#8203;(java.lang.String&nbsp;query,
                                 <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery,
                                 java.lang.Object&nbsp;precompLookup,
                                 java.sql.Connection&nbsp;explainConnection,
                                 <a href="QueryOptimiserContext.html" title="class in org.intermine.sql.precompute">QueryOptimiserContext</a>&nbsp;context)
                          throws java.sql.SQLException</pre>
<div class="block">Runs the optimiser through the query represented in the String and Query, given the
 Connection and an object to lookup a PrecomputedTable</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>query</code> - the query String to optimise</dd>
<dd><code>originalQuery</code> - the Query object to optimise - or optionally null</dd>
<dd><code>precompLookup</code> - a Database or Connection to lookup a PrecomputedTableManager</dd>
<dd><code>explainConnection</code> - the database connection to use, or null if precompLookup is a
 Database</dd>
<dd><code>context</code> - a QueryOptimiserContext, to alter settings</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a BestQuery object</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database error occurs</dd>
</dl>
</li>
</ul>
<a id="optimiseWith(java.lang.String,org.intermine.sql.query.Query,org.intermine.sql.Database,java.sql.Connection,org.intermine.sql.precompute.QueryOptimiserContext,java.util.Set,org.intermine.sql.precompute.OptimiserCache)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>optimiseWith</h4>
<pre class="methodSignature">public static&nbsp;<a href="BestQuery.html" title="class in org.intermine.sql.precompute">BestQuery</a>&nbsp;optimiseWith&#8203;(java.lang.String&nbsp;query,
                                     <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery,
                                     <a href="../Database.html" title="class in org.intermine.sql">Database</a>&nbsp;database,
                                     java.sql.Connection&nbsp;connection,
                                     <a href="QueryOptimiserContext.html" title="class in org.intermine.sql.precompute">QueryOptimiserContext</a>&nbsp;context,
                                     java.util.Set&lt;<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&gt;&nbsp;precomputedTables,
                                     <a href="OptimiserCache.html" title="class in org.intermine.sql.precompute">OptimiserCache</a>&nbsp;cache)
                              throws java.sql.SQLException</pre>
<div class="block">Runs the optimiser through the query repesented in the String and Query, given the Connection
 and a set of PrecomputedTables.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>query</code> - the query String to optimise</dd>
<dd><code>originalQuery</code> - the Query object to optimise - or optionally null</dd>
<dd><code>database</code> - a Database</dd>
<dd><code>connection</code> - the database connection to use, or null if database is a Database</dd>
<dd><code>context</code> - a QueryOptimiserContext, to alter settings</dd>
<dd><code>precomputedTables</code> - a Set of PrecomputedTables</dd>
<dd><code>cache</code> - an OptimiserCache</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a BestQuery object</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.sql.SQLException</code> - if a database error occurs</dd>
</dl>
</li>
</ul>
<a id="remapAliasesToAvoidPrecomputePrefix(org.intermine.sql.query.Query)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>remapAliasesToAvoidPrecomputePrefix</h4>
<pre class="methodSignature">protected static&nbsp;void&nbsp;remapAliasesToAvoidPrecomputePrefix&#8203;(<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query)</pre>
<div class="block">Remaps the aliases of any table that starts with the ALIAS_PREFIX, to avoid clashes with
 future precomputed tables.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>query</code> - the query to remap</dd>
</dl>
</li>
</ul>
<a id="recursiveOptimiseCheckSubquery(java.util.Set,org.intermine.sql.query.Query,org.intermine.sql.precompute.BestQuery)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recursiveOptimiseCheckSubquery</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;recursiveOptimiseCheckSubquery&#8203;(java.util.Set&lt;<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&gt;&nbsp;precomputedTables,
                                                  <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
                                                  <a href="BestQuery.html" title="class in org.intermine.sql.precompute">BestQuery</a>&nbsp;bestQuery)
                                           throws <a href="BestQueryException.html" title="class in org.intermine.sql.precompute">BestQueryException</a>,
                                                  java.sql.SQLException</pre>
<div class="block">Recursively optimises the query, given the set of precomputed tables, and updates the
 BestQuery object with each Query found. This method looks for simple subqueries to
 optimise, and calls recursiveOptimise.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>precomputedTables</code> - a Set of PrecomputedTable objects to use</dd>
<dd><code>query</code> - a query to optimise</dd>
<dd><code>bestQuery</code> - a BestQuery object to update with each optimised Query object</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="BestQueryException.html" title="class in org.intermine.sql.precompute">BestQueryException</a></code> - if the BestQuery decides to cut short the search</dd>
<dd><code>java.sql.SQLException</code> - if a database error occurs</dd>
</dl>
</li>
</ul>
<a id="recursiveOptimise(java.util.Set,org.intermine.sql.query.Query,org.intermine.sql.precompute.BestQuery,org.intermine.sql.query.Query)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>recursiveOptimise</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;recursiveOptimise&#8203;(java.util.Set&lt;<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&gt;&nbsp;precomputedTables,
                                     <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
                                     <a href="BestQuery.html" title="class in org.intermine.sql.precompute">BestQuery</a>&nbsp;bestQuery,
                                     <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery)
                              throws <a href="BestQueryException.html" title="class in org.intermine.sql.precompute">BestQueryException</a>,
                                     java.sql.SQLException</pre>
<div class="block">Recursively optimises the query, given the set of precomputed tables, and updates the
 BestQuery object with each Query found.
 When this method returns, either bestQuery will hold the fastest Query, or the bestQuery
 object will have decided to cut short proceedings. Either way, use the Query in bestQuery
 for best results.
 NOTE: the Query passed into this method at the top level should never be used again by
 anything (except when this method is called by this method), because this method alters the
 query. Therefore it is recommended that all Queries are passed into this method as fresh
 clones of the Query you wish to optimise.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>precomputedTables</code> - a Set of PrecomputedTable objects to use</dd>
<dd><code>query</code> - a query to optimise</dd>
<dd><code>bestQuery</code> - a BestQuery object to update with each optimised Query object</dd>
<dd><code>originalQuery</code> - the original Query, as passed to the first instance of
 recursiveOptimise.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="BestQueryException.html" title="class in org.intermine.sql.precompute">BestQueryException</a></code> - if the BestQuery decides to cut short the search</dd>
<dd><code>java.sql.SQLException</code> - if a database error occurs</dd>
</dl>
</li>
</ul>
<a id="mergeMultiple(java.util.Set,org.intermine.sql.query.Query,org.intermine.sql.query.Query)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeMultiple</h4>
<pre class="methodSignature">protected static&nbsp;java.util.SortedMap&lt;<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>,&#8203;java.util.Set&lt;<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&gt;&gt;&nbsp;mergeMultiple&#8203;(java.util.Set&lt;<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&gt;&nbsp;precomputedTables,
                                                                                                <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
                                                                                                <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery)</pre>
<div class="block">Iteratively calls merge on query with all the PrecomputedTables in a Set, returning the
 results in a Map from the PrecomputedTable to the Set that merge returns.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>precomputedTables</code> - a Set of PrecomputedTable objects to iterate through</dd>
<dd><code>query</code> - the Query to pass in to merge</dd>
<dd><code>originalQuery</code> - the original Query, as passed to the first instance of
 recursiveOptimise.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Map from all PrecomputedTable objects that produced a non-empty Set, to the Set
 that was produced by merge</dd>
</dl>
</li>
</ul>
<a id="merge(org.intermine.sql.precompute.PrecomputedTable,org.intermine.sql.query.Query,org.intermine.sql.query.Query)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre class="methodSignature">protected static&nbsp;java.util.Set&lt;<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&gt;&nbsp;merge&#8203;(<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&nbsp;precomputedTable,
                                            <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
                                            <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery)</pre>
<div class="block">Finds all the possible uses of a given precomputed table in the query, and returns them as
 a Set of new Queries.
 If there is no scope for the PrecomputedTable to replace any part of the Query, then this
 method will return an empty Set.
 If there are two independent opportunities to insert the PrecomputedTable, then this method
 will return three Query objects in the Set - one with the first opportunity used, one with
 the second opportunity used, and one with both.
 A PrecomputedTable is deemed to "fit", if it <ol>
 <li>Contains no other tables than those present in the Query</li>
 <li>Contains no constraints that restrict the output more than the constraints of the Query.
 Constraints that equal a constraint in the Query can be missed out of the resulting
 Query</li>
 <li>A similar restriction on the HAVING clauses as the WHERE clauses.</li>
 <li>Contains all the items in the SELECT list that are present in the Query's SELECT from the
 tables that are to be replaced</li>
 <li>If the PrecomputedTable is DISTINCT, then the Query must also be DISTINCT.</li>
 </ol>
 This type of precomputed table can be fitted multiple times.
 Note that a subquery could be replaced completely by a precomputed table, or can be optimised
 in-place by another precomputed table (in which case merge should call itself with the
 subquery).
 Alternatively, If the PrecomputedTable contains a GROUP BY, then all fields in the Query's
 SELECT list and all primary keys, that are not to be replaced by the PrecomputedTable must
 be in the Query's GROUP BY clause, and the fields in the GROUP BY for the tables that are
 being replaced must match completely. Also, all the fields in the SELECT list of the query
 must be present in the PrecomputedTable. This type of PrecomputedTable can only be fitted
 once.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>precomputedTable</code> - the PrecomputedTable to use in the new Queries</dd>
<dd><code>query</code> - the Query object to try to fit the PrecomputedTable into</dd>
<dd><code>originalQuery</code> - the original Query, as passed to the first instance of
 recursiveOptimise.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Set of Query objects, one for each combination of the PrecomputedTable in the
 query</dd>
</dl>
</li>
</ul>
<a id="mergeGroupBy(org.intermine.sql.precompute.PrecomputedTable,org.intermine.sql.query.Query,org.intermine.sql.query.Query)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeGroupBy</h4>
<pre class="methodSignature">protected static&nbsp;java.util.Set&lt;<a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&gt;&nbsp;mergeGroupBy&#8203;(<a href="PrecomputedTable.html" title="class in org.intermine.sql.precompute">PrecomputedTable</a>&nbsp;precomputedTable,
                                                   <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;query,
                                                   <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;originalQuery)</pre>
<div class="block">Tries to match a PrecomputedTable with a GROUP BY clause to this query.
 See merge for a description of how this works. In fact, we aren't implementing this
 properly. We are imposing the restriction that there can be no more tables than in the
 PrecomputedTable, therefore the first restriction mentioned above is followed automatically.
 A PrecomputedTable is deemed to fit if it <ol>
 <li>Contains exactly the same set of tables as the Query</li>
 <li>Contains exactly the same WHERE clause as the Query</li>
 <li>Contains all the items in the SELECT list that are present in the Query's SELECT
 list.</li>
 <li>Contains exactly the same GROUP BY clause</li>
 </ol>
 So, this leaves very little leeway for optimising different Queries - these are the things
 that can be different from the PrecomputedTable: <ol>
 <li>The HAVING clause may be different, although each constraint in the PrecomputedTable
 must EQUAL or IMPLIES some constraint in the Query.</li>
 <li>the DISTINCT status can be different, but if the PrecomputedTable is DISTINCT, then
 the Query must also be DISTINCT.</li>
 </ol></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>precomputedTable</code> - the PrecomputedTable to use in the new Query</dd>
<dd><code>query</code> - the Query object to try to fit the PrecomputedTable into</dd>
<dd><code>originalQuery</code> - the original query object</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Set containing maybe a new Query object with the PrecomputedTable inserted</dd>
</dl>
</li>
</ul>
<a id="compareConstraints(java.util.Set,java.util.Set,java.util.Set)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareConstraints</h4>
<pre class="methodSignature">protected static&nbsp;boolean&nbsp;compareConstraints&#8203;(java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;set1,
                                            java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;set2,
                                            java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;equalsSet)</pre>
<div class="block">Compares 2 sets of AbstractConstraints</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>set1</code> - the first set</dd>
<dd><code>set2</code> - the second set</dd>
<dd><code>equalsSet</code> - a Set that should be passed in empty - it will be populated with those
 AbstractConstraints that have an equal in the other set. Note that if the return value is
 false, then the contents of this Set is undefined</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if every element of set1 is equal or less restrictive
 than some element in set2</dd>
</dl>
</li>
</ul>
<a id="compareConstraints(java.util.Set,java.util.Set,java.util.Set,java.util.Map,java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareConstraints</h4>
<pre class="methodSignature">protected static&nbsp;boolean&nbsp;compareConstraints&#8203;(java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;set1,
                                            java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;set2,
                                            java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;equalsSet,
                                            java.util.Map&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>,&#8203;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableMap,
                                            java.util.Map&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>,&#8203;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;reverseTableMap)</pre>
<div class="block">Compares 2 sets of AbstractConstraints</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>set1</code> - the first set</dd>
<dd><code>set2</code> - the second set</dd>
<dd><code>equalsSet</code> - a Set that should be passed in empty - it will be populated with those
 AbstractConstraints that have an equal in the other set. Note that if the return value is
 false, then the contents of this Set is undefined</dd>
<dd><code>tableMap</code> - a Map from Table to Table</dd>
<dd><code>reverseTableMap</code> - the reverse of tableMap</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if every element of set1 is equal or less restrictive
 than some element in set2</dd>
</dl>
</li>
</ul>
<a id="compareSelectLists(java.util.List,java.util.List)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareSelectLists</h4>
<pre class="methodSignature">protected static&nbsp;boolean&nbsp;compareSelectLists&#8203;(java.util.List&lt;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;list1,
                                            java.util.List&lt;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;list2)</pre>
<div class="block">Compares two Lists of SelectValues, and returns true if all the items in the first List are
 present in the second List, ignoring the SelectValue alias.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>list1</code> - the list of items that must be present in list2</dd>
<dd><code>list2</code> - the list of items to look in</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if every item in list1 is present in list2, ignoring SelectValue aliases
 TODO: take this function out - we don't need it.</dd>
</dl>
</li>
</ul>
<a id="remapAliases(java.util.Map,java.util.Set)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>remapAliases</h4>
<pre class="methodSignature">protected static&nbsp;void&nbsp;remapAliases&#8203;(java.util.Map&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>,&#8203;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;map,
                                   java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tables)</pre>
<div class="block">Alters all the aliases of the tables being mapped to, to equal the alias of the table mapping
 to them. After this operation (where the AbstractTables of the PrecomputedTable are mapped
 to the AbstractTables of the Query), the Constraint objects of the Query and the
 PrecomputedTable can be directly compared with their standard compare methods.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>map</code> - the Map from AbstractTable objects with the source alias, to other AbstractTable
 objects with the destination alias</dd>
<dd><code>tables</code> - a Set of tables which the values of the map happen to be in. This permits this
 method to check that none of the tables that it is about to change the alias of will clash
 with any pre-existing table aliases. Pre-existing table aliases will be renamed as necessary.</dd>
</dl>
</li>
</ul>
<a id="findTableForAlias(java.lang.String,java.util.Set)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findTableForAlias</h4>
<pre class="methodSignature">protected static&nbsp;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&nbsp;findTableForAlias&#8203;(java.lang.String&nbsp;alias,
                                                 java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;set)</pre>
<div class="block">Finds a table in a Set with the given alias.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>alias</code> - the alias to look for</dd>
<dd><code>set</code> - the Set to look in</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an AbstractTable that has the alias or null if there isn't one</dd>
</dl>
</li>
</ul>
<a id="reconstructAbstractValue(org.intermine.sql.query.AbstractValue,org.intermine.sql.query.Table,java.util.Map,java.util.Set,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reconstructAbstractValue</h4>
<pre class="methodSignature">protected static&nbsp;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>&nbsp;reconstructAbstractValue&#8203;(<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>&nbsp;original,
                                                        <a href="../query/Table.html" title="class in org.intermine.sql.query">Table</a>&nbsp;precomputedSqlTable,
                                                        java.util.Map&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>,&#8203;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;valueMap,
                                                        java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableSet,
                                                        boolean&nbsp;groupBy)
                                                 throws <a href="QueryOptimiserException.html" title="class in org.intermine.sql.precompute">QueryOptimiserException</a></pre>
<div class="block">Reconstructs an AbstractValue, to form the part of an SQL Query that has been replaced with
 a PrecomputedTable. If the AbstractValue is present in the SELECT list of the
 PrecomputedTable, then a new Field replaces the AbstractValue, that is that particular
 field in the PrecomputedTable. Otherwise, the original AbstractValue will be returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>original</code> - the original AbstractValue</dd>
<dd><code>precomputedSqlTable</code> - the Table object representing the PrecomputedTable, which the
 new AbstractValue should refer to.</dd>
<dd><code>valueMap</code> - a mapping from AbstractValue in the PrecomputedTable onto the SelectValue
 that contains it.</dd>
<dd><code>tableSet</code> - a Set of all the tables that are being replaced - ie the Set of tables in the
 PrecomputedTable. We use this to work out which unrepresented AbstractValues are problems.</dd>
<dd><code>groupBy</code> - true if the PrecomputedTable contains a GROUP BY clause</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a remapped AbstractValue</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="QueryOptimiserException.html" title="class in org.intermine.sql.precompute">QueryOptimiserException</a></code> - if there is an AbstractValue that cannot be constructed,
 because it is not present in the PrecomputedTable</dd>
</dl>
</li>
</ul>
<a id="reconstructSelectValues(java.util.List,org.intermine.sql.query.Table,java.util.Map,java.util.Set,boolean,org.intermine.sql.query.Query)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reconstructSelectValues</h4>
<pre class="methodSignature">protected static&nbsp;void&nbsp;reconstructSelectValues&#8203;(java.util.List&lt;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;oldSelect,
                                              <a href="../query/Table.html" title="class in org.intermine.sql.query">Table</a>&nbsp;precomputedSqlTable,
                                              java.util.Map&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>,&#8203;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;valueMap,
                                              java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableSet,
                                              boolean&nbsp;groupBy,
                                              <a href="../query/Query.html" title="class in org.intermine.sql.query">Query</a>&nbsp;newQuery)
                                       throws <a href="QueryOptimiserException.html" title="class in org.intermine.sql.precompute">QueryOptimiserException</a></pre>
<div class="block">Populates the SELECT list of a new Query object, given an old Query's SELECT list to use as a
 reference, a valueMap (to pass to reconstructAbstractValue), and a Table to represent the
 PrecomputedTable.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>oldSelect</code> - the old Query's SELECT list to use a pattern</dd>
<dd><code>precomputedSqlTable</code> - the Table object that remapped AbstractValues should refer to</dd>
<dd><code>valueMap</code> - a mapping from AbstractValue in the PrecomputedTable onto the SelectValue
 that contains it</dd>
<dd><code>tableSet</code> - a Set of all the tables that are being replaced - ie the Set of tables in the
 PrecomputedTable. We use this to work out which unrepresented AbstractValues are problems.</dd>
<dd><code>groupBy</code> - true if the PrecomputedTable contains a GROUP BY clause</dd>
<dd><code>newQuery</code> - the new Query object to populate</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="QueryOptimiserException.html" title="class in org.intermine.sql.precompute">QueryOptimiserException</a></code> - if reconstructAbstractValue finds an AbstractValue that
 cannot be constructed, given the PrecomputedTable</dd>
</dl>
</li>
</ul>
<a id="reconstructAbstractConstraints(java.util.Set,org.intermine.sql.query.Table,java.util.Map,java.util.Set,boolean,java.util.Set,java.util.Set,org.intermine.sql.query.Field,int,org.intermine.sql.query.Field,boolean,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reconstructAbstractConstraints</h4>
<pre class="methodSignature">protected static&nbsp;void&nbsp;reconstructAbstractConstraints&#8203;(java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;oldConstraints,
                                                     <a href="../query/Table.html" title="class in org.intermine.sql.query">Table</a>&nbsp;precomputedSqlTable,
                                                     java.util.Map&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>,&#8203;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;valueMap,
                                                     java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableSet,
                                                     boolean&nbsp;groupBy,
                                                     java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;newConstraints,
                                                     java.util.Set&lt;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&gt;&nbsp;constraintEqualsSet,
                                                     <a href="../query/Field.html" title="class in org.intermine.sql.query">Field</a>&nbsp;firstPrecompOrderBy,
                                                     int&nbsp;precompOrderBySize,
                                                     <a href="../query/Field.html" title="class in org.intermine.sql.query">Field</a>&nbsp;orderByField,
                                                     boolean&nbsp;firstPrecompOrderByHasNoNulls,
                                                     boolean&nbsp;reverseOrderBy)
                                              throws <a href="QueryOptimiserException.html" title="class in org.intermine.sql.precompute">QueryOptimiserException</a></pre>
<div class="block">Populates the WHERE list of a new Query object, given the old Query's WHERE (or HAVING) list
 to use as a reference.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>oldConstraints</code> - a Set of constraints from the old Query</dd>
<dd><code>precomputedSqlTable</code> - the Table object that remapped AbstractValues should refer to</dd>
<dd><code>valueMap</code> - a mapping from AbstractValue in the PrecomputedTable onto the SelectValue
 that contains it.</dd>
<dd><code>tableSet</code> - a Set of all the tables that are being replaced - ie the Set of tables in the
 PrecomputedTable. We use this to work out which unrepresented AbstractValues are problems.</dd>
<dd><code>groupBy</code> - true if the PrecomputedTable contains a GROUP BY clause</dd>
<dd><code>newConstraints</code> - the Set of Constraints in the Query that is being created</dd>
<dd><code>constraintEqualsSet</code> - a Set of Constraints that are present in both the original query
 and the precomputed table - therefore they can be left out of the new Query</dd>
<dd><code>firstPrecompOrderBy</code> - a Field that the column corresponding to the first order by
 field in the precomputed table would be mapped onto in the destination query</dd>
<dd><code>precompOrderBySize</code> - the number of elements in the precomputed table's order by clause</dd>
<dd><code>orderByField</code> - a Field that can replace the firstPrecompOrderBy field</dd>
<dd><code>firstPrecompOrderByHasNoNulls</code> - true if the firstPrecompOrderBy field does not permit
 null values</dd>
<dd><code>reverseOrderBy</code> - true if the firstPrecompOrderBy was an OrderDescending</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="QueryOptimiserException.html" title="class in org.intermine.sql.precompute">QueryOptimiserException</a></code> - if reconstructAbstractValue finds an AbstractValue that
 cannot be constructed, given the PrecomputedTable</dd>
</dl>
</li>
</ul>
<a id="reconstructAbstractConstraint(org.intermine.sql.query.AbstractConstraint,org.intermine.sql.query.Table,java.util.Map,java.util.Set,boolean,org.intermine.sql.query.Field,int,org.intermine.sql.query.Field,boolean,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reconstructAbstractConstraint</h4>
<pre class="methodSignature">protected static&nbsp;<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&nbsp;reconstructAbstractConstraint&#8203;(<a href="../query/AbstractConstraint.html" title="class in org.intermine.sql.query">AbstractConstraint</a>&nbsp;oldConstraint,
                                                                  <a href="../query/Table.html" title="class in org.intermine.sql.query">Table</a>&nbsp;precomputedSqlTable,
                                                                  java.util.Map&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>,&#8203;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;valueMap,
                                                                  java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableSet,
                                                                  boolean&nbsp;groupBy,
                                                                  <a href="../query/Field.html" title="class in org.intermine.sql.query">Field</a>&nbsp;firstPrecompOrderBy,
                                                                  int&nbsp;precompOrderBySize,
                                                                  <a href="../query/Field.html" title="class in org.intermine.sql.query">Field</a>&nbsp;orderByField,
                                                                  boolean&nbsp;firstPrecompOrderByHasNoNulls,
                                                                  boolean&nbsp;reverseOrderBy)
                                                           throws <a href="QueryOptimiserException.html" title="class in org.intermine.sql.precompute">QueryOptimiserException</a></pre>
<div class="block">Reconstructs an AbstractConstraint object, using reconstructAbstractValue.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>oldConstraint</code> - the constraint to reconstruct</dd>
<dd><code>precomputedSqlTable</code> - the Table object that remapped AbstractValues should refer to</dd>
<dd><code>valueMap</code> - a mapping from AbstractValue in the PrecomputedTable onto the SelectValue
 that contains it.</dd>
<dd><code>tableSet</code> - a Set of all the tables that are being replaced - ie the Set of tables in the
 PrecomputedTable. We use this to work out which unrepresented AbstractValues are problems.</dd>
<dd><code>groupBy</code> - true if the PrecomputedTable contains a GROUP BY clause</dd>
<dd><code>firstPrecompOrderBy</code> - a Field that the column corresponding to the first order by
 field in the precomputed table would be mapped onto in the destination query</dd>
<dd><code>precompOrderBySize</code> - the number of elements in the precomputed table's order by clause</dd>
<dd><code>orderByField</code> - a Field that can replace the firstPrecompOrderBy field</dd>
<dd><code>firstPrecompOrderByHasNoNulls</code> - true if the firstPrecompOrderBy field does not permit
 null values</dd>
<dd><code>reverseOrderBy</code> - true if the firstPrecompOrderBy was an OrderDescending</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an AbstractConstraint that uses AbstractValues reconstructed by
 reconstructAbstractValue</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="QueryOptimiserException.html" title="class in org.intermine.sql.precompute">QueryOptimiserException</a></code> - if reconstructAbstractValue finds an AbstractValue that
 cannot be constructed, given the PrecomputedTable</dd>
</dl>
</li>
</ul>
<a id="reconstructAbstractValues(java.util.Collection,org.intermine.sql.query.Table,java.util.Map,java.util.Set,boolean,java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reconstructAbstractValues</h4>
<pre class="methodSignature">public static&nbsp;void&nbsp;reconstructAbstractValues&#8203;(java.util.Collection&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>&gt;&nbsp;oldValues,
                                             <a href="../query/Table.html" title="class in org.intermine.sql.query">Table</a>&nbsp;precomputedSqlTable,
                                             java.util.Map&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>,&#8203;<a href="../query/SelectValue.html" title="class in org.intermine.sql.query">SelectValue</a>&gt;&nbsp;valueMap,
                                             java.util.Set&lt;<a href="../query/AbstractTable.html" title="class in org.intermine.sql.query">AbstractTable</a>&gt;&nbsp;tableSet,
                                             boolean&nbsp;groupBy,
                                             java.util.Collection&lt;<a href="../query/AbstractValue.html" title="class in org.intermine.sql.query">AbstractValue</a>&gt;&nbsp;newValues)
                                      throws <a href="QueryOptimiserException.html" title="class in org.intermine.sql.precompute">QueryOptimiserException</a></pre>
<div class="block">Reconstructs a Collection of AbstractValue objects, calling reconstructAbstractValue on each
 one before adding it to another Collection. Reconstructed values will be added to the
 destination Collection in the same order as the iterator of the original Collection.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>oldValues</code> - the Collection of AbstractValue objects to reconstruct</dd>
<dd><code>precomputedSqlTable</code> - the Table object that remapped AbstractValues should refer to</dd>
<dd><code>valueMap</code> - a mapping from AbstractValue in the PrecomputedTable onto the SelectValue
 that contains it.</dd>
<dd><code>tableSet</code> - a Set of all the tables that are being replaced - ie the Set of tables in the
 PrecomputedTable. We use this to work out which unrepresented AbstractValues are problems.</dd>
<dd><code>groupBy</code> - true if the PrecomputedTable contains a GROUP BY clause</dd>
<dd><code>newValues</code> - the Collection to put the reconstructed AbstractValues in</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="QueryOptimiserException.html" title="class in org.intermine.sql.precompute">QueryOptimiserException</a></code> - if reconstructAbstractValue finds an AbstractValue that
 cannot be constructed, given the PrecomputedTable</dd>
</dl>
</li>
</ul>
<a id="addNonCoveredFrom(java.util.Set,java.util.Set,java.util.Set)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>addNonCoveredFrom</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;void&nbsp;addNonCoveredFrom&#8203;(java.util.Set&lt;T&gt;&nbsp;input,
                                         java.util.Set&lt;T&gt;&nbsp;subtract,
                                         java.util.Set&lt;T&gt;&nbsp;output)</pre>
<div class="block">Adds all required FROM items to the FROM list of the new query. Adds all items in input,
 minus the items in subtract, to the Set output.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - The element type</dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>input</code> - a Set of items to be added to the output</dd>
<dd><code>subtract</code> - a Set of items to miss out</dd>
<dd><code>output</code> - a destination Set to add items to</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
